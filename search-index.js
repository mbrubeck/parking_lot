var searchIndex = {};
searchIndex["parking_lot_core"] = {"doc":"This library exposes a low-level API for creating your own efficient\nsynchronization primitives.","items":[[3,"UnparkResult","parking_lot_core","Result of an unpark operation.",null,null],[12,"unparked_threads","","The number of threads that were unparked.",0,null],[12,"have_more_threads","","Whether there are any threads remaining in the queue. This only returns\ntrue if a thread was unparked.",0,null],[12,"be_fair","","This is set to true on average once every 0.5ms for any given key. It\nshould be used to switch to a fair unlocking mechanism for a particular\nunlock.",0,null],[3,"UnparkToken","","A value which is passed from an unparker to a parked thread.",null,null],[12,"0","","",1,null],[3,"ParkToken","","A value associated with a parked thread which can be used by `unpark_filter`.",null,null],[12,"0","","",2,null],[3,"SpinWait","","A counter used to perform exponential backoff in spin loops.",null,null],[4,"ParkResult","","Result of a park operation.",null,null],[13,"Unparked","","We were unparked by another thread with the given token.",3,null],[13,"Invalid","","The validation callback returned false.",3,null],[13,"TimedOut","","The timeout expired.",3,null],[4,"RequeueOp","","Operation that `unpark_requeue` should perform.",null,null],[13,"Abort","","Abort the operation without doing anything.",4,null],[13,"UnparkOneRequeueRest","","Unpark one thread and requeue the rest onto the target queue.",4,null],[13,"RequeueAll","","Requeue all threads onto the target queue.",4,null],[4,"FilterOp","","Operation that `unpark_filter` should perform for each thread.",null,null],[13,"Unpark","","Unpark the thread and continue scanning the list of parked threads.",5,null],[13,"Skip","","Don&#39;t unpark the thread and continue scanning the list of parked threads.",5,null],[13,"Stop","","Don&#39;t unpark the thread and stop scanning the list of parked threads.",5,null],[5,"park","","Parks the current thread in the queue associated with the given key.",null,{"inputs":[{"name":"usize"},{"name":"v"},{"name":"b"},{"name":"t"},{"name":"parktoken"},{"name":"option"}],"output":{"name":"parkresult"}}],[5,"unpark_one","","Unparks one thread from the queue associated with the given key.",null,{"inputs":[{"name":"usize"},{"name":"c"}],"output":{"name":"unparkresult"}}],[5,"unpark_all","","Unparks all threads in the queue associated with the given key.",null,{"inputs":[{"name":"usize"},{"name":"unparktoken"}],"output":{"name":"usize"}}],[5,"unpark_requeue","","Removes all threads from the queue associated with `key_from`, optionally\nunparks the first one and requeues the rest onto the queue associated with\n`key_to`.",null,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"v"},{"name":"c"}],"output":{"name":"unparkresult"}}],[5,"unpark_filter","","Unparks a number of threads from the front of the queue associated with\n`key` depending on the results of a filter function which inspects the\n`ParkToken` associated with each thread.",null,{"inputs":[{"name":"usize"},{"name":"f"},{"name":"c"}],"output":{"name":"unparkresult"}}],[11,"new","","Creates a new `SpinWait`.",6,{"inputs":[],"output":{"name":"spinwait"}}],[11,"reset","","Resets a `SpinWait` to its initial state.",6,null],[11,"spin","","Spins until the sleep threshold has been reached.",6,null],[11,"spin_no_yield","","Spins without yielding the thread to the OS.",6,null],[11,"default","","",6,{"inputs":[],"output":{"name":"spinwait"}}],[11,"clone","","",3,null],[11,"eq","","",3,null],[11,"ne","","",3,null],[11,"fmt","","",3,null],[11,"is_unparked","","Returns true if we were unparked by another thread.",3,null],[11,"clone","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"fmt","","",0,null],[11,"clone","","",4,null],[11,"eq","","",4,null],[11,"fmt","","",4,null],[11,"clone","","",5,null],[11,"eq","","",5,null],[11,"fmt","","",5,null],[11,"clone","","",1,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"fmt","","",1,null],[11,"clone","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"fmt","","",2,null],[17,"DEFAULT_UNPARK_TOKEN","","A default unpark token to use.",null,null],[17,"DEFAULT_PARK_TOKEN","","A default park token to use.",null,null]],"paths":[[3,"UnparkResult"],[3,"UnparkToken"],[3,"ParkToken"],[4,"ParkResult"],[4,"RequeueOp"],[4,"FilterOp"],[3,"SpinWait"]]};
searchIndex["parking_lot"] = {"doc":"This library provides implementations of `Mutex`, `RwLock`, `Condvar` and\n`Once` that are smaller, faster and more flexible than those in the Rust\nstandard library.","items":[[3,"Once","parking_lot","A synchronization primitive which can be used to run a one-time\ninitialization. Useful for one-time initialization for globals, FFI or\nrelated functionality.",null,null],[3,"OnceState","","State yielded to the `call_once_force` method which can be used to query\nwhether the `Once` was previously poisoned or not.",null,null],[3,"Mutex","","A mutual exclusion primitive useful for protecting shared data",null,null],[3,"MutexGuard","","An RAII implementation of a &quot;scoped lock&quot; of a mutex. When this structure is\ndropped (falls out of scope), the lock will be unlocked.",null,null],[3,"Condvar","","A Condition Variable",null,null],[3,"WaitTimeoutResult","","A type indicating whether a timed wait on a condition variable returned\ndue to a time out or not.",null,null],[3,"RwLock","","A reader-writer lock",null,null],[3,"RwLockReadGuard","","RAII structure used to release the shared read access of a lock when\ndropped.",null,null],[3,"RwLockWriteGuard","","RAII structure used to release the exclusive write access of a lock when\ndropped.",null,null],[11,"fmt","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"clone","","",0,null],[11,"timed_out","","Returns whether the wait was known to have timed out.",0,null],[11,"new","","Creates a new condition variable which is ready to be waited on and\nnotified.",1,{"inputs":[],"output":{"name":"condvar"}}],[11,"notify_one","","Wakes up one blocked thread on this condvar.",1,null],[11,"notify_all","","Wakes up all blocked threads on this condvar.",1,null],[11,"wait","","Blocks the current thread until this condition variable receives a\nnotification.",1,null],[11,"wait_until","","Waits on this condition variable for a notification, timing out after\nthe specified time instant.",1,null],[11,"wait_for","","Waits on this condition variable for a notification, timing out after a\nspecified duration.",1,null],[11,"default","","",1,{"inputs":[],"output":{"name":"condvar"}}],[11,"new","","Creates a new mutex in an unlocked state ready for use.",2,{"inputs":[{"name":"t"}],"output":{"name":"mutex"}}],[11,"into_inner","","Consumes this mutex, returning the underlying data.",2,null],[11,"lock","","Acquires a mutex, blocking the current thread until it is able to do so.",2,null],[11,"try_lock","","Attempts to acquire this lock.",2,null],[11,"try_lock_for","","Attempts to acquire this lock until a timeout is reached.",2,null],[11,"try_lock_until","","Attempts to acquire this lock until a timeout is reached.",2,null],[11,"get_mut","","Returns a mutable reference to the underlying data.",2,null],[11,"raw_unlock","","Releases the mutex.",2,null],[11,"raw_unlock_fair","","Releases the mutex using a fair unlock protocol.",2,null],[11,"raw_lock","","Acquires a mutex, blocking the current thread until it is able to do so.",2,null],[11,"raw_try_lock","","Attempts to acquire this lock.",2,null],[11,"default","","",2,{"inputs":[],"output":{"name":"mutex"}}],[11,"fmt","","",2,null],[11,"unlock_fair","","Unlocks the mutex using a fair unlock protocol.",3,null],[11,"deref","","",3,null],[11,"deref_mut","","",3,null],[11,"drop","","",3,null],[11,"new","","Creates a new instance of an `RwLock&lt;T&gt;` which is unlocked.",4,{"inputs":[{"name":"t"}],"output":{"name":"rwlock"}}],[11,"into_inner","","Consumes this `RwLock`, returning the underlying data.",4,null],[11,"read","","Locks this rwlock with shared read access, blocking the current thread\nuntil it can be acquired.",4,null],[11,"try_read","","Attempts to acquire this rwlock with shared read access.",4,null],[11,"try_read_for","","Attempts to acquire this rwlock with shared read access until a timeout\nis reached.",4,null],[11,"try_read_until","","Attempts to acquire this rwlock with shared read access until a timeout\nis reached.",4,null],[11,"write","","Locks this rwlock with exclusive write access, blocking the current\nthread until it can be acquired.",4,null],[11,"try_write","","Attempts to lock this rwlock with exclusive write access.",4,null],[11,"try_write_for","","Attempts to acquire this rwlock with exclusive write access until a\ntimeout is reached.",4,null],[11,"try_write_until","","Attempts to acquire this rwlock with exclusive write access until a\ntimeout is reached.",4,null],[11,"get_mut","","Returns a mutable reference to the underlying data.",4,null],[11,"raw_unlock_read","","Releases shared read access of the rwlock.",4,null],[11,"raw_unlock_write","","Releases exclusive write access of the rwlock.",4,null],[11,"raw_unlock_read_fair","","Releases shared read access of the rwlock using a fair unlock protocol.",4,null],[11,"raw_unlock_write_fair","","Releases exclusive write access of the rwlock using a fair unlock\nprotocol.",4,null],[11,"raw_read","","Locks this rwlock with shared read access, blocking the current thread\nuntil it can be acquired.",4,null],[11,"raw_try_read","","Attempts to acquire this rwlock with shared read access.",4,null],[11,"raw_write","","Locks this rwlock with exclusive write access, blocking the current\nthread until it can be acquired.",4,null],[11,"raw_try_write","","Attempts to lock this rwlock with exclusive write access.",4,null],[11,"default","","",4,{"inputs":[],"output":{"name":"rwlock"}}],[11,"fmt","","",4,null],[11,"unlock_fair","","Unlocks the `RwLock` using a fair unlock protocol.",5,null],[11,"deref","","",5,null],[11,"drop","","",5,null],[11,"downgrade","","Atomically downgrades a write lock into a read lock without allowing any\nwriters to take exclusive access of the lock in the meantime.",6,null],[11,"unlock_fair","","Unlocks the `RwLock` using a fair unlock protocol.",6,null],[11,"deref","","",6,null],[11,"deref_mut","","",6,null],[11,"drop","","",6,null],[11,"poisoned","","Returns whether the associated `Once` has been poisoned.",7,null],[11,"new","","Creates a new `Once` value.",8,{"inputs":[],"output":{"name":"once"}}],[11,"call_once","","Performs an initialization routine once and only once. The given closure\nwill be executed if this is the first time `call_once` has been called,\nand otherwise the routine will *not* be invoked.",8,null],[11,"call_once_force","","Performs the same function as `call_once` except ignores poisoning.",8,null],[11,"default","","",8,{"inputs":[],"output":{"name":"once"}}],[6,"MutexGuardRef","","Typedef of an owning reference that uses a `MutexGuard` as the owner.",null,null],[6,"RwLockReadGuardRef","","Typedef of an owning reference that uses a `RwLockReadGuard` as the owner.",null,null],[6,"RwLockWriteGuardRef","","Typedef of an owning reference that uses a `RwLockWriteGuard` as the owner.",null,null],[17,"ONCE_INIT","","Initialization value for static `Once` values.",null,null]],"paths":[[3,"WaitTimeoutResult"],[3,"Condvar"],[3,"Mutex"],[3,"MutexGuard"],[3,"RwLock"],[3,"RwLockReadGuard"],[3,"RwLockWriteGuard"],[3,"OnceState"],[3,"Once"]]};
initSearch(searchIndex);
